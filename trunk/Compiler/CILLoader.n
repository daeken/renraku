using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Cil.OpCodes;

using Nextem.String;
using Nextem.Switch;

namespace Renraku.Compiler {
	public variant CILArg {
		| Stack
		| Local {
			Index : uint
		}
		| Arg {
			Num : int
		}
		| VInt {
			Val : int
		}
		| VUInt {
			Val : uint
		}
		| VShort {
			Val : short
		}
		| VUShort {
			Val : ushort
		}
		
		public override ToString() : string {
			match(this) {
				| Stack => "stack"
				| Local(ind) => "local({0})" <- ind
				| Arg(num) => "arg({0})" <- num
				| VInt(val) => "int({0})" <- val
				| VUInt(val) => "uint({0})" <- val
				| VShort(val) => "short({0})" <- val
				| VUShort(val) => "ushort({0})" <- val
			}
		}
	}
	
	public type CILBody = list [int * Inst [CILArg, int]];
	
	public module CILLoader {
		public Load(fn : string) : Assembly [CILBody] {
			def ParseBody(insts, off, accum : CILBody = []) {
				if(off == -1) accum
				else {
					def inst = insts[off];
					if(inst.OpCode == Nop)
						ParseBody(insts, off-1, accum)
					else
						ParseBody(
							insts,
							off-1,
							(
								inst.Offset, 
								switch(inst.OpCode) {
									| Ldarg_0 => Inst.Push(CILArg.Arg(0))
									
									| Ldc_I4_S  => Inst.Push(CILArg.VInt((inst.Operand :> sbyte) :> int))
									| Ldc_I4_M1 => Inst.Push(CILArg.VInt(-1))
									| Ldc_I4_0  => Inst.Push(CILArg.VInt(0))
									| Ldc_I4_1  => Inst.Push(CILArg.VInt(1))
									| Ldc_I4_2  => Inst.Push(CILArg.VInt(2))
									| Ldc_I4_3  => Inst.Push(CILArg.VInt(3))
									| Ldc_I4_4  => Inst.Push(CILArg.VInt(4))
									| Ldc_I4_5  => Inst.Push(CILArg.VInt(5))
									| Ldc_I4_6  => Inst.Push(CILArg.VInt(6))
									| Ldc_I4_7  => Inst.Push(CILArg.VInt(7))
									| Ldc_I4_8  => Inst.Push(CILArg.VInt(8))
									
									| Add => Inst.Binary(Op.@+, false, CILArg.Stack(), (CILArg.Stack(), CILArg.Stack()))
									| Sub => Inst.Binary(Op.@-, false, CILArg.Stack(), (CILArg.Stack(), CILArg.Stack()))
									| Mul => Inst.Binary(Op.@*, false, CILArg.Stack(), (CILArg.Stack(), CILArg.Stack()))
									| Add_Ovf => Inst.Binary(Op.@+, true, CILArg.Stack(), (CILArg.Stack(), CILArg.Stack()))
									| Sub_Ovf => Inst.Binary(Op.@-, true, CILArg.Stack(), (CILArg.Stack(), CILArg.Stack()))
									| Mul_Ovf => Inst.Binary(Op.@*, true, CILArg.Stack(), (CILArg.Stack(), CILArg.Stack()))
									
									| And => Inst.Binary(Op.@&, false, CILArg.Stack(), (CILArg.Stack(), CILArg.Stack()))
									
									| Not => Inst.Unary(Op.@~, CILArg.Stack(), CILArg.Stack())
									

									| Beq => Inst.Branch((Op.@==, CILArg.Stack(), CILArg.Stack()), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Beq_S => Inst.Branch((Op.@==, CILArg.Stack(), CILArg.Stack()), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Bge => Inst.Branch((Op.@>=, CILArg.Stack(), CILArg.Stack()), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Bge_S => Inst.Branch((Op.@>=, CILArg.Stack(), CILArg.Stack()), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Bge_Un  => Inst.Branch((Op.@>=, CILArg.Stack(), CILArg.Stack()), true, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Bge_Un_S => Inst.Branch((Op.@>=, CILArg.Stack(), CILArg.Stack()), true, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Bgt => Inst.Branch((Op.@>, CILArg.Stack(), CILArg.Stack()), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Bgt_S => Inst.Branch((Op.@>, CILArg.Stack(), CILArg.Stack()), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Bgt_Un => Inst.Branch((Op.@>, CILArg.Stack(), CILArg.Stack()), true, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Bgt_Un_S => Inst.Branch((Op.@>, CILArg.Stack(), CILArg.Stack()), true, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Ble => Inst.Branch((Op.@<=, CILArg.Stack(), CILArg.Stack()), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Ble_S => Inst.Branch((Op.@<=, CILArg.Stack(), CILArg.Stack()), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Ble_Un => Inst.Branch((Op.@<=, CILArg.Stack(), CILArg.Stack()), true, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Ble_Un_S => Inst.Branch((Op.@<=, CILArg.Stack(), CILArg.Stack()), true, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Blt => Inst.Branch((Op.@<, CILArg.Stack(), CILArg.Stack()), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Blt_S => Inst.Branch((Op.@<, CILArg.Stack(), CILArg.Stack()), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Blt_Un => Inst.Branch((Op.@<, CILArg.Stack(), CILArg.Stack()), true, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Blt_Un_S => Inst.Branch((Op.@<, CILArg.Stack(), CILArg.Stack()), true, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Bne_Un => Inst.Branch((Op.@!=, CILArg.Stack(), CILArg.Stack()), true, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Bne_Un_S => Inst.Branch((Op.@!=, CILArg.Stack(), CILArg.Stack()), true, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									
									| Br => Inst.Branch((Op.Nil, CILArg.Stack(), null), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Br_S => Inst.Branch((Op.Nil, CILArg.Stack(), null), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Brfalse => Inst.Branch((Op.@==, CILArg.Stack(), CILArg.VInt(0)), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Brfalse_S => Inst.Branch((Op.@==, CILArg.Stack(), CILArg.VInt(0)), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Brtrue => Inst.Branch((Op.@!=, CILArg.Stack(), CILArg.VInt(0)), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									| Brtrue_S => Inst.Branch((Op.@!=, CILArg.Stack(), CILArg.VInt(0)), false, (inst.Operand :> Instruction).Offset, inst.Offset+inst.GetSize())
									
									| Ret => Inst.Return(CILArg.Stack())
									
									| _ =>
										print "Unhandled opcode: {0} {1}" <- (inst.OpCode, inst.Operand);
										null
								}
							) :: accum
						)
				}
			}
			
			def asm = AssemblyFactory.GetAssembly(fn);
			
			mutable types = [];
			
			foreach(mod :> ModuleDefinition in asm.Modules)
				foreach(typ :> TypeDefinition in mod.Types) {
					unless(typ.Name == "<Module>") {
						mutable members = [];
						foreach(meth :> MethodDefinition in typ.Methods)
							members ::=
								Assembly.Method.[CILBody](
									meth.Name,
									([], meth.ReturnType.ReturnType.Name),
									ParseBody(meth.Body.Instructions, meth.Body.Instructions.Count-1)
								);
						types ::= Assembly.Class(typ.Name, members)
					}
				}
			
			Assembly.Top(types)
		}
	}
}
