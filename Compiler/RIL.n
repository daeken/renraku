using System;

using Nextem.String;

namespace Renraku {
	public enum Op {
		| @=
		| @<=>
		
		| @+
		| @-
		| @*
		| @/
		| @**
		| @%
		
		| Cmp
		| @!
		| @==
		| @!=
		| @<
		| @>
		| @<=
		| @>=
		
		| @|
		| @&
		| @^
		| @~
	}
	
	public variant CILArg {
		| Stack
		| Local {
			Index : uint
		}
		| Arg {
			Num : uint
		}
		
		public override ToString() : string {
			match(this) {
				| Stack => "Stack"
				| Local(ind) => "local({0})" <- ind
				| Arg(num) => "arg({0})" <- num
			}
		}
	}
	
	public variant Inst [ArgT, LabelT] {
		| Push {
			Src : ArgT
		}
		| Pop {
			Dest : ArgT
		}
		
		| Unary {
			Op : Op;
			Dest : ArgT;
			Src : ArgT
		}
		| Binary {
			Op : Op;
			Dest : ArgT;
			Opers : ArgT * ArgT
		}
		
		| Branch {
			Comp : Op?;
			Taken : LabelT;
			NotTaken : LabelT
		}
		
		public override ToString() : string {
			match(this) {
				| Push(arg) => "push({0})" <- arg
				| Pop(arg)  => "{0} = pop()" <- arg
				| Unary(op, dest, src) =>
					"{0} = {1} {2}" <- (dest, op, src)
				| Binary(op, dest, (a, b)) =>
					"{0} = {1} {2} {3}" <- (dest, a, op, b)
				| Branch(comp, taken, not) =>
					if(comp == null)
						"branch({0})" <- taken
					else
						"branch({0}, {1}, {2})" <- (comp, taken, not)
			}
		}
	}
	
	public variant RType {
		| Native {
			Type : Type
		}
		| Other {
			Type : string
		}
		
		public override ToString() : string {
			match(this) {
				| Native(typ) => typ.ToString()
				| Other(typ) => typ
			}
		}
	}
	
	public variant Assembly [MBodyT] {
		| Top
		| Namespace {
			Name : String
		}
		| Class {
			Name : String
		}
		| Field {
			Name : String;
			Type : RType
		}
		| Property {
			Name : String;
			Type : RType;
			Getter : Method;
			Setter : Method
		}
		| Method {
			Name : String;
			Type : list [RType] * RType;
			Body : MBodyT
		}
		
		public Children : list [Assembly [MBodyT]];
		
		public override ToString() : string {
			def iterChild(list, accum : string = null) {
				match(list) {
					| null => ""
					| [] => accum
					| head :: tail =>
						iterChild(
							tail, 
							if(accum == null)
								head.ToString()
							else
								"{0}, {1}" <- (accum, head.ToString())
						)
				}
			}
			
			"({0} ({1}))" <- (
					match(this) {
						| Top => "top"
						| Namespace(name) => "ns:{0}" <- name
						| Class(name) => "class:{0}" <- name
						| _ => this.GetType().ToString()
					},
					iterChild(Children)
				)
		}
	}
}
